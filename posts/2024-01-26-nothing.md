---
layout: post
title: Reversing the Nothing Phone 2 Lights
description: Blinkenlights for all!
tags: [android, reverse-engineering]
---

In September, I got a [Nothing Phone 2](https://us.nothing.tech/pages/phone-2), that gimmick phone with the flashy lights on the back. In January, I resumed involvement with the [LDSP](/2023/06/17/ldsp) project involving rooting Android phones to give applications low-level control over their sensors and audio interfaces. I began to stare at the lights on the back of my phone and think, "Why can't I write my own apps to blink these?"

This post documents my efforts to reverse-engineer those lights.

# Prior Work

When I started researching this, almost every thread led me to the work of [rec0de](rec0de.net) in [this repo](https://github.com/rec0de/glyph-api). They highlighted a few potential avenues.

## Android Hardware Lights Service

Nothing decided to use the [Android Hardware Lights Service](), which has a really nice API:

```java
class Light {
    int getId();
    String getName();
    boolean hasBrightnessControl();
    boolean hasRgbControl();
}

class LightState {
    int getColor();
}

class LightsRequest {
    class Builder {
        Builder addLight(Light light, LightState state);
        Builder clearLight(Light light);
        LightsRequest build();
    }

    List<LightState> getLightStates();
    List<Integer> getLights();
    Map<Light, LightState> getLightsAndStates();
}

class LightsManager {
    class LightsSession {
        void close();
        void requestLights(LightsRequest request);
    }

    LightState getLightState(Light light);
    List<Light> getLights();
    LightsManager.LightSession openSession();
}
```

Awesome, this is perfect! Let's just write an app that uses these APIs, request the `CONTROL_DEVICE_LIGHTS_PERMISSION` in our `AndroidManifest.xml`, and... no dice, since that permission is restricted to system apps only. This wouldn't be worth posting if things were that easy.

## Glyph Composer

But there _are_ non-system apps that have these permissions: the [Glyph Composer](https://play.google.com/store/apps/details?id=com.nothing.glyph.composer&hl=en_US&gl=US) by Nothing (which lets you define your own ringtone light patterns) and [Uber](https://www.theverge.com/2023/7/4/23783503/nothing-phone-2-hands-on-mkbhd-glyph-interface) (which uses the lights to indicate driver progress). Somehow, these need to control the lights.

Let's focus on the Glyph Composer first. rec0de discovered from decompiling the Glyph Composer app that it binds to a service called `com.nothing.thirdparty.bind_glyphservice`:

```java
public final void b() {
    Object m7;
    r3.a aVar = this.f2457d;
    aVar.getClass();
    try {
        if (aVar.f6404b == 0) {
            s3.a b7 = aVar.b();
            b7.getClass();
            Intent intent = new Intent();
            intent.setPackage("com.nothing.thirdparty");
            intent.setAction("com.nothing.thirdparty.bind_glyphservice");
            intent.setComponent(new ComponentName("com.nothing.thirdparty", "com.nothing.thirdparty.GlyphService"));
            b7.f6730a.bindService(intent, b7.f6731b, 1);
            Log.i("GlyphComposer_GlyphManagerCompat", "init");
        }
        int i7 = aVar.f6404b;
        aVar.f6404b = i7 + 1;
        m7 = Integer.valueOf(i7);
    } catch (Throwable th) {
        m7 = e1.m(th);
    }
    Throwable a7 = h4.d.a(m7);
    if (a7 != null) {
        String str = "init error:" + a7;
        h.e(str, "message");
        Log.e("GlyphComposer_GlyphManagerCompat", str);
    }
}
```

Let's see if we can replicate this and do a little more digging. I downloaded the [Glyph Composer APK](https://www.apkmirror.com/apk/nothing-technology-limited/glyph-composer/glyph-composer-1-3-3-release/), and since I didn't feel like parsing Smali again, I ran [Bytecode Viewer](https://github.com/konloch/bytecode-viewer). Note that I needed to downgrade my Java version from 21.0 to 11.0 for it to work properly.

After dragging and dropping the .apk in, I went to File -> Decompile and Save All Classes and chose CFR. (Procyon kept giving me a StackOverflowError). This took a few minutes to finish, but eventually left me a .zip full of classes. The method that rec0de found is right there in `z3/e.java`, called `b()`. Luckily, we ended up with the same minification.

So can we find the rest of the interface including `setFrameColors`? The only mention I could find of it is in some error handling code here:

```java
public final Object c(List<Integer> var1_1, h5.d<? super h> var2_4) {
    // ...
    try {
        block24: {
            var2_4 /* !! */  = var2_4 /* !! */ .b().c;
            if (var2_4 /* !! */  == null) {
                var1_1 = "Service is null";
            } else {
                try {
                    var2_4 /* !! */ .a((int[])var1_1);
                    break block24;
                }
                catch (RemoteException var1_2) {
                    var1_1 = var1_2.getMessage();
                }
            }
            Log.e((String)"GlyphManager", (String)var1_1);
        }
        var1_1 = e5.h.a;
    }
    catch (Throwable var1_3) {
        var1_1 = r.g((Throwable)var1_3);
    }
    var2_4 /* !! */  = e5.d.a((Object)var1_1);
    if (var2_4 /* !! */  == null) return e5.h.a;
    var1_1 = new StringBuilder();
    var1_1.append("setFrameColors error:");
    var1_1.append(var2_4 /* !! */ );
    var1_1 = var1_1.toString();
    q5.i.e((Object)var1_1, (String)"message");
    Log.e((String)"GlyphComposer_GlyphManagerCompat", (String)var1_1);
    return e5.h.a;
}
```

It seems like our decompiler struggled to get everything, but we can still get the rough idea. There's some service, and if we can manage to bind with it, we're in business.

## Uber

Another approach identified by [Raghav Bhardwaj](https://github.com/Raghav-B) is to [spoof the Uber app](https://github.com/rec0de/glyph-api/pull/1), triggering notifications from the `com.ubercab` package which the Nothing Phone picks up on to indicate the driver distance on the LEDs. This has a few limitations:

- We'd be limited to the patterns that Nothing provides for the Uber integration
- A notification would need to be present all the time
- The user can't have the official Uber app on their phone at all

Due to the more limited control this offers, I'm going to initially try sticking to the Glyph Composer approach.

# Finding the Glyph Service

How do we peek inside this `GlyphService`? One approach would be to try to analyze the Nothing OS image.

## The Search for GlyphService

Let's download [version 2.0.1](https://www.androidsage.com/2023/08/23/download-nothing-os-2-0-2a-update-for-phone-2/), since it's the latest I can find that isn't just an incremental image.

I wasn't able to unzip it with the macOS file manager, but the CLI worked:

```bash
$ unzip 7becde0f47753b99a7cc37ff27713ba8a48ef51a.zip
Archive:  7becde0f47753b99a7cc37ff27713ba8a48ef51a.zip
signed by SignApk
 extracting: META-INF/com/android/metadata
 extracting: META-INF/com/android/metadata.pb
 extracting: apex_info.pb
 extracting: care_map.pb
 extracting: payload.bin
 extracting: payload_properties.txt
  inflating: META-INF/com/android/otacert
```

We don't have much to go off of.

```bash
$ file payload.bin
payload.bin: data
```

```bash
$ cat payload_properties.txt
FILE_HASH=7PZYDSt9dO1ggg1qdso0bLoTklOCrbW9+vH5OlFjYTk=
FILE_SIZE=87131265
METADATA_HASH=X5wPQ3hpA9Rklm9ZAN2KhTLKE3yT7kA4E2zZzVobBlY=
METADATA_SIZE=536884
POST_OTA_VERSION=Pong_T2.0-231024-2214
PRE_OTA_VERSION=Pong_T2.0-230906-1933
```

It seems like `payload.bin` has our magic. From some googling, I found [cyxx's `extract_android_ota_payload` script](https://github.com/cyxx/extract_android_ota_payload). Note that it only works with older versions of `protobuf`:

```bash
pip3 install google protobuf==3.20.0
brew install xz
git clone https://github.com/cyxx/extract_android_ota_payload.git
cd extract_android_ota_payload
python3 extract_android_ota_payload.py ../Downloads/payload.bin test
```

This gives us a lot of separate `.img` files:

```
$ ls test
abl.img           devcfg.img        keymaster.img     qupfw.img         tz.img            vendor.img
aop.img           dsp.img           modem.img         qweslicstore.img  uefi.img          vendor_boot.img
aop_config.img    dtbo.img          multiimgoem.img   recovery.img      uefisecapp.img    vendor_dlkm.img
bluetooth.img     featenabler.img   multiimgqti.img   shrm.img          vbmeta.img        xbl.img
boot.img          hyp.img           odm.img           system.img        vbmeta_system.img xbl_config.img
cpucp.img         imagefv.img       product.img       system_ext.img    vbmeta_vendor.img xbl_ramdump.img
$ file system.img
system.img: Linux rev 1.0 ext2 filesystem data, UUID=b9fd8ef2-cce2-59a6-b08e-7807d1e5c059 (extents) (large files) (huge files)
```

I've been following along on a Mac so far, but since mounting .img files on macOS is a pain, I'll copy my work over to a Linux VM.

Let's mount the `system.img` one, since that looks promising:

```bash
mkdir /mnt/system
sudo mount -t ext4 -o ro /home/$USER/test/system.img /mnt/system
```

Note that the `ro` option is needed since there's an extra feature flag (`4000`) set. If you're struggling with mounting, remember that `mount` will just print a generic error message to the terminal but will send a much more detailed error to `dmesg`.

A quick Google indicates that our system apps should be in `/system/app`:

```
$ ls /mnt/system/system/app
BasicDreams                       HTMLViewer
Bluetooth                         KeyChain
BluetoothMidiService              NfcNci
BookmarkProvider                  NothingPAIStub
CameraExtensionsProxy             NothingWallpapersBasicColorStub
CaptivePortalLoginGoogle          NothingWallpapersStub
CarrierDefaultApp                 PacProcessor
CertInstaller                     PartnerBookmarksProvider
CompanionDeviceManager            PrintSpooler
EasterEgg                         SecureElement
GfDisplayTest                     SimAppDialog
GoogleExtShared                   Stk
GooglePrintRecommendationService  Traceur
GTMTest                           WallpaperBackup
```

Nothing obvious jumps out yet. This isn't anything wallpaper-related, so maybe `NothingPAIStub`? Inside the folder is a `NothingPAIStub.apk` file, let's take a look.

```bash
unzip NothingPAIStub.apk
Archive:  NothingPAIStub.apk
  inflating: META-INF/com/android/build/gradle/app-metadata.properties
  inflating: AndroidManifest.xml
  inflating: res/xml/clientid.xml
 extracting: resources.arsc
```

Oddly enough, there's no `classes.dex` file, so no Java code here. It doesn't seem like there's any native code either, just configuration files. `resources.arsc` seems like some sort of binary configuration format. Let's keep looking.

There's another directory in `/system`, called `priv-app`:

```
$ ls /mnt/system/system/priv-app
BackupRestoreConfirmation         MediaProviderLegacy
BlockedNumberProvider             MmsService
BuiltInPrintService               MtpService
CalendarProvider                  MusicFX
CallLogBackup                     NetworkStackGoogle
CellBroadcastLegacyApp            NothingAppService
ContactsProvider                  NothingDiracService
DiagSwitch                        NothingDiracService_DMP
DiracAudioControlService          NothingExperience
DiracAudioControlService_DMP      NothingExperimental
DocumentsUIGoogle                 NothingSoundRecorder
DownloadProvider                  NTCamera
DownloadProviderUi                ONS
DynamicSystemInstallationService  ProxyHandler
ExternalStorageProvider           SettingsProvider
FaceRecognition                   SharedStorageBackup
FactoryTest                       Shell
FusedLocation                     SmartVoice
GooglePackageInstaller            SoundPicker
GrantPermission                   TagGoogle
InputDevices                      Telecom
LedTest                           TelephonyProvider
LiveWallpapersPicker              TeleService
LocalTransport                    UserDictionaryProvider
ManagedProvisioning               VpnDialogs
```

Lots of these are vaguely-named, but Dirac seems to be a media-related thing. Maybe `NothingAppService` is a general-purpose service provider of some sort?

```
$ ls /mnt/system/system/priv-app/NothingAppService
NothingAppService.apk
oat
$ ls /mnt/system/system/priv-app/NothingAppService/oat/arm64
NothingAppService.odex
NothingAppService.vdex
```

What are these files?

- `NothingAppService.apk` is our traditional `.apk`, containing `AndroidManifest.xml` and others.
- `NothingAppService.odex` and `NothingAppService.vdex` are pre-compiled Java code -- essentially running the Java JIT ahead of time to avoid needing to run it on every boot. My understanding is that `.vdex` is a newer format that replaces `.odex`.

We should be able to understand everything just from looking at the `.apk`, so let's load it into Bytecode Viewer:

![](nothing-phone/NothingAppService.png)

It looks like everything in here just has to do with notification delivery. Is there anything relating to `Glyph` on this partition? We can use ripgrep:

```
$ sudo rg "glyph"
system/etc/fonts.xml
14:    the glyph).
1052:        <font weight="400" style="normal" postScriptName="NotoSansEgyptianHieroglyphs">
1053:            NotoSansEgyptianHieroglyphs-Regular.ttf
1365:        <font weight="400" style="normal">NotoSansAnatolianHieroglyphs-Regular.otf</font>
$ sudo rg "Glyph"
system/etc/preloaded-classes
2166:android.graphics.text.PositionedGlyphs
```

Looks like the only results relate to font glyphs.

Maybe the system partition isn't the place to look. Android also has the vendor partition, which [is used for vendor or OEM specific code](https://xdaforums.com/t/info-android-device-partitions-and-filesystems.3586565/). Maybe we can mount that?

```
$ cd /mnt/vendor
$ sudo rg "glyph"
$ sudo rg "Glyph"
```

No dice. Maybe the [product partition](https://source.android.com/docs/core/architecture/partitions/product-partitions)?

Not much in product:

```
$ sudo rg "glyph"
usr/srec/en-US/wordlist.syms
35937:hieroglyphics	35936

usr/srec/en-US/TERSE_LSTM_LM.lstm_lm.syms
37153:hieroglyphics	37152
```

But there is something in `system_ext`:

```
$ sudo find . -name "*Glyph*"
./system_ext/app/GlyphNotification
./system_ext/app/GlyphNotification/oat/arm64/GlyphNotification.vdex
./system_ext/app/GlyphNotification/oat/arm64/GlyphNotification.odex
./system_ext/app/GlyphNotification/GlyphNotification.apk
```

Let's unpack, and... bingo.

![](nothing-phone/GlyphNotification.png)

We've got the exact interface that [rec0de identified](https://github.com/rec0de/glyph-api).

```java
package com.nothing.thirdparty;

import android.os.IInterface;
import android.os.RemoteException;

public interface IGlyphService extends IInterface {
   String DESCRIPTOR = "com.nothing.thirdparty.IGlyphService";

   void closeSession() throws RemoteException;
   void openSession() throws RemoteException;
   boolean register(String var1) throws RemoteException;
   void setFrameColors(int[] var1) throws RemoteException;
}
```

We can also see the Uber and Zomato integration sources here:

![](nothing-phone/Uber.png)

![](nothing-phone/Zomato.png)

# The Glyph Source Code

## Just Exploring

We can find a few useful definitions, including for each of the lighting zones:

```java
package com.nothing.ketchum;

public class Glyph {
   public static int A1;
   public static int A2;
   public static int B1;
   public static int C1_1;
   public static int C1_10;
   public static int C1_11;
   public static int C1_12;
   public static int C1_13;
   public static int C1_14;
   public static int C1_15;
   public static int C1_16;
   public static int C1_2;
   public static int C1_3;
   public static int C1_4;
   public static int C1_5;
   public static int C1_6;
   public static int C1_7;
   public static int C1_8;
   public static int C1_9;
   public static int C2;
   public static int C3;
   public static int C4;
   public static int C5;
   public static int C6;
   public static int D1_1;
   public static int D1_2;
   public static int D1_3;
   public static int D1_4;
   public static int D1_5;
   public static int D1_6;
   public static int D1_7;
   public static int D1_8;
   public static int E1;
}
```

Let's turn our eyes to `GlyphManager`, since it seems like where most of the magic happens:

```java
package com.nothing.ketchum;

public class GlyphManager {
   private static final int DEFAULT_MAX_LIGHT = 4096;
   private static final int DEFAULT_MIN_LIGHT = 800;
   private static final int GLYPH_C = 1;
   private static final int GLYPH_D = 2;
   private static final int NO_LIGHT = 0;
   private static final String TAG = "GlyphManager";
   private static GlyphManager mInstance;
   private Callback mCallback;
   private RemoteServiceConnection mConnection = new RemoteServiceConnection(this, (RemoteServiceConnection_IA)null);
   private Context mContext;
   private ExecutorService mExecutor;
   private boolean mFrameTask = false;
   private boolean mHasAuthorized = false;
   private IGlyphService mService;
   private Future mTask = null;

   private GlyphManager(Context var1) {
      this.mContext = var1;
      this.mExecutor = Executors.newSingleThreadExecutor();
   }

   private void displayProgress(GlyphFrame var1, int var2, boolean var3, boolean var4) throws GlyphException {
      if (!this.mHasAuthorized) {
         Log.d("GlyphManager", "Non registed");
      } else {
         this.stopCurrentTask();
         int[] var6 = var1.getChannel();
         if (var6[Glyph.C1_1] == 0 && var6[Glyph.D1_1] == 0 || var6[Glyph.C1_1] > 0 && var6[Glyph.D1_1] > 0) {
            throw new GlyphException("Please choose C1 or D1 while using display progress.");
         } else {
            byte var5;
            if (var6[Glyph.C1_1] == 0) {
               var5 = 2;
            } else {
               var5 = 1;
            }

            this.executeFrame(new 4(this, var3, var5, var2, var4, var6));
         }
      }
   }

   private void executeFrame(Runnable var1) {
      this.mTask = this.mExecutor.submit(var1);
   }

   public static GlyphManager getInstance(Context var0) {
      if (mInstance == null) {
         mInstance = new GlyphManager(var0);
      }

      return mInstance;
   }

   private boolean hasLight(int var1) {
      return var1 > 0;
   }

   private boolean isTaskOn() {
      return this.mFrameTask;
   }

   private void pauseAWhile(long var1) {
      try {
         Thread.sleep(var1);
      } catch (InterruptedException var4) {
         Log.e("GlyphManager", var4.getMessage());
      }

   }

   private void stopCurrentTask() {
      Future var1 = this.mTask;
      if (var1 != null) {
         var1.cancel(true);
      }

   }

   public void animate(GlyphFrame var1) {
      if (!this.mHasAuthorized) {
         Log.d("GlyphManager", "Non registed");
      } else {
         this.stopCurrentTask();
         this.executeFrame(new 3(this, var1));
      }
   }

   public void closeSession() throws GlyphException {
      if (!this.mHasAuthorized) {
         Log.d("GlyphManager", "Non registed");
      } else if (this.mService != null) {
         try {
            this.stopCurrentTask();
            this.mService.closeSession();
         } catch (RemoteException var2) {
            Log.d("GlyphManager", var2.getMessage());
         }

      } else {
         throw new GlyphException("Please use it after service connected.");
      }
   }

   public void displayProgress(GlyphFrame var1, int var2) throws GlyphException {
      this.displayProgress(var1, var2, false, false);
   }

   public void displayProgress(GlyphFrame var1, int var2, boolean var3) throws GlyphException {
      this.displayProgress(var1, var2, var3, false);
   }

   public void displayProgressAndToggle(GlyphFrame var1, int var2, boolean var3) throws GlyphException {
      this.displayProgress(var1, var2, var3, true);
   }

   public void init(Callback var1) {
      this.mCallback = var1;
      Intent var2 = new Intent();
      var2.setPackage("com.nothing.thirdparty");
      var2.setAction("com.nothing.thirdparty.bind_glyphservice");
      var2.setComponent(new ComponentName("com.nothing.thirdparty", "com.nothing.thirdparty.GlyphService"));
      this.mContext.bindService(var2, this.mConnection, 1);
   }

   public void openSession() throws GlyphException {
      if (!this.mHasAuthorized) {
         Log.d("GlyphManager", "Non registed");
      } else {
         IGlyphService var1 = this.mService;
         if (var1 != null) {
            try {
               var1.openSession();
            } catch (RemoteException var2) {
               Log.d("GlyphManager", var2.getMessage());
            }

         } else {
            throw new GlyphException("Please use it after service connected.");
         }
      }
   }

   public boolean register() {
      try {
         String var1 = Common.getAppKey(this.mContext);
         this.mHasAuthorized = this.mService.register(var1);
      } catch (RemoteException var2) {
         Log.e("GlyphManager", var2.getMessage());
      } catch (Exception var3) {
         Log.e("GlyphManager", var3.getMessage(), var3);
      }

      return this.mHasAuthorized;
   }

   public void setFrameColors(int[] var1) throws GlyphException {
      if (!this.mHasAuthorized) {
         Log.d("GlyphManager", "Non registed");
      } else if (this.mService != null) {
         this.stopCurrentTask();
         this.executeFrame(new 1(this, var1));
      } else {
         throw new GlyphException("Please use it after service connected.");
      }
   }

   public void toggle(GlyphFrame var1) {
      if (!this.mHasAuthorized) {
         Log.d("GlyphManager", "Non registed");
      } else {
         this.stopCurrentTask();
         this.executeFrame(new 2(this, var1));
      }
   }

   public void unInit() {
      this.mContext.unbindService(this.mConnection);
   }
}
```

Let's step through how we expect this class could be used.

- The constructor sets up a new the context and an executor
- We call `init()` to bind to the GlyphService
- We register with `register()`, getting a boolean back on whether we could authorize successfully
- We start a session with `openSession()`
- We set colors with `toggle()`, `setFrameColors()`, `displayProgress()`, `animate()`...
- We close with `closeSession()`

It seems like we still haven't found the "core" registration logic. But since we know exactly what it's called, let's see if we can narrow in on it more quickly:

```
$ sudo grep -Flrn "GlyphService" .
./system_ext/app/GlyphNotification/GlyphNotification.apk
./system_ext/app/NtThirdParty/NtThirdParty.apk
```

We were just in `GlyphNotification.apk`, and didn't see anything, but `NtThirdParty.apk` seems more promising, since the service is in the `com.nothing.thirdparty` package. Let's take a look.

![](nothing-phone/GlyphService.png)

Here we have it.

## The GlyphService

The GlyphService is the gatekeeper between us and the glyph lights. So how does it let in the Glyph Composer? Let's take a look at the first nested class (`GlyphService$1.class`), which implements our `IGlyphService`, and focus in on the `openSession` method. Note that the method is very long so I've cleaned it up a bit:

```java
public void openSession() throws RemoteException {
    HashMap var6 = GlyphService._$$Nest$fgetmSessionMap(this.this$0);
    synchronized(var6){}

    Throwable var10000;
    boolean var10001;
    label1340: {
        int var4;
        String var7;
        try {
            var7 = Utils.getCallingPackageName(GlyphService._$$Nest$fgetmContext(this.this$0));
            var4 = Utils.getCallingUid();
        } catch (Throwable var140) {
            var10000 = var140;
            var10001 = false;
            break label1340;
        }

        byte var2 = 115;

        boolean var5;
        try {
            var5 = "com.nothing.glyph.composer".equals(var7);
        } catch (Throwable var139) {
            var10000 = var139;
            var10001 = false;
            break label1340;
        }

        boolean var1;
        boolean var3;
        label1328: {
            label1327: {
                var3 = true;
                if (var5) {
                    try {
                        if (Utils.checkFingerprint(GlyphService._$$Nest$fgetmContext(this.this$0), var7)) {
                        GlyphService._$$Nest$fgetmAuth(this.this$0).addAlreadyAuth(var7, var4);
                        break label1327;
                        }
                    } catch (Throwable var138) {
                        var10000 = var138;
                        var10001 = false;
                        break label1340;
                    }
                }

                var1 = false;
                break label1328;
            }

            var2 = 110;
            var1 = true;
        }

        if (var4 == 1000) {
            var1 = true;
        }

        try {
            if (!GlyphService._$$Nest$fgetmUidPkgMap(this.this$0).containsKey(var4)) {
                GlyphService._$$Nest$fgetmUidPkgMap(this.this$0).put(var4, var7);
            }
        } catch (Throwable var137) {
            var10000 = var137;
            var10001 = false;
        break label1340;
        }

        try {
            if (!GlyphService._$$Nest$fgetmAuth(this.this$0).checkAlreadyAuth((String)GlyphService._$$Nest$fgetmUidPkgMap(this.this$0).get(var4))) {
                return;
            }
        } catch (Throwable var136) {
            var10000 = var136;
            var10001 = false;
            break label1340;
        }

        label1312: {
            try {
                if (!GlyphService._$$Nest$fgetmAuth(this.this$0).checkForeground(var7)) {
                    break label1312;
                }
            } catch (Throwable var135) {
                var10000 = var135;
                var10001 = false;
                break label1340;
            }

            var1 = var3;
        }

        // ...
    }
}
```

This is a lot, but we can step through the ways that a package may be authorized:

- If its package name is `com.nothing.glyph.composer` and it passes the check in `Utils.checkFingerprint`
- If its UID is 1000 (i.e., it is a system app)
- If it passes `checkAlreadyAuth`

If we're not the Glyph Composer, and we don't want to root our phone, the third option seems the most promising.

### Can we register?

Let's trace what a call to `register()` does...

```java
public boolean register(String var1) throws RemoteException {
    if (GlyphService._$$Nest$sfgetDBG()) {
        Log.d("GlyphService", "register");
    }

    String var3 = Utils.getCallingPackageName(GlyphService._$$Nest$fgetmContext(this.this$0));
    int var2 = Utils.getCallingUid();
    return GlyphService._$$Nest$fgetmAuth(this.this$0).register(var3, var1, var2);
}
```

Following the call down to `AuthController`, we get this method. I think `var3` is UID (since it's again compared to 1000), and `var1` is the package name. We can see that since we aren't a system app, we'll be passed along to `Utils.getCertificateFingerprint`.

```java
public boolean register(String var1, String var2, int var3) {
    if (var1 != null && var2 != null && !"".equals(var2)) {
        if (var3 == 1000) {
            if (Def.DBG) {
                Log.d("AuthController", "register(), system uid");
            }

            this.addAlreadyAuth(var1, var3, 2);
            return true;
        } else {
            AuthApp var4 = (AuthApp)this.mAuthMap.get(var1);
            if (var4 == null) {
                if (Def.DBG) {
                    Log.d("AuthController", "Wrong pkg");
                }

                return false;
            } else {
                var4.setUid(var3);
                return var4.checkAuth(var2, Utils.getCertificateFingerprint(this.mContext, var1));
            }
        }
    } else {
        if (Def.DBG) {
            StringBuilder var5 = new StringBuilder();
            var5.append("pkg:");
            var5.append(var1);
            var5.append(", uid:");
            var5.append(var3);
            Log.d("AuthController", var5.toString());
        }

        return false;
    }
}
```

What does `Utils.getCertificateFingerprint` have in store for us? I'm not going to reproduce it here since the decompiler mangled the try/catch statements pretty badly, but it boils down to taking a SHA1 hash of the package signatures. The fingerprint is then looked up in the `mAuthMap` field, which is loaded from a JSON object in the `parseConfig` method in `AuthController`, which expects the fields `pkg`, `scope`, `apikey`, and `signature`.

TL;DR: if we don't want to beg for an API key from Nothing, we're out of luck for this route.

## Becoming GlyphService

The astute reader might notice that we take a slightly different code path if our package name is `com.nothing.glyph.composer`. Can that get us anywhere? Remember, we need to pass the `Utils.checkFingerprint` check. So what exactly is that check?

```java
public static boolean checkFingerprint(Context var0, String var1) {
    return getCertificateFingerprint(var0, var1).contains("95E1F157FE98518");
}
```

...so we get the fingerprint as above for our `com.nothing.glyph.composer` package, and then instead of comparing it against a JSON object, we... check if the SHA1 hash contains a certain _substring_?

### Let's do the math

It wouldn't be a breq.dev post if there weren't some math involved, so let's dust off our combinatorics skills.

We're looking for a specific 60-bit substring in a 160-bit hash, but since each hex character is 4 bits, we need it to be aligned to a 4-bit boundary. That gives us positions of [0, 4, 8, ..., 100], so 20 possibilities for it to appear in.

For each of those possibilities, we have 100 unconstrained bits, giving us $2^{100}$ possibilities. The total number of hashes is $2^{160}$. So the proportion of keys we're looking for is roughly:

$$
\frac{2^{100} \cdot 30}{2^{160}} \approx 2.602 \times 10^-17
$$

We can compare this to a typical "key breaking" operation by putting this in terms of a power of 2:

$$
\log_2 (2.602 \times 10^-17) \approx 2^{-55}
$$

It's the equivalent of brute-forcing a 55-bit key.

A recent [paper](https://www.sciencedirect.com/science/article/abs/pii/S1383762122000066) found that an RTX 3070 could crack a DES key (56 bits) in 215 days. We're effectively 1 bit off from that, _but_ we've got the added work of actually producing a working Android package that meets that signature. Plus, it'd probably take a few tweaks to the code to anyway, and at an iteration cycle on the order of months, that's pretty painful.

## What about that JSON config thing?

Maybe we need to play the same tricks that we did in [the Transit reversing project](/2023/06/16/transitapp-reversing) to try to rewrite this JSON payload?

The `AuthController`'s `init` method looks like this:

```java
this.mRemoteConfig = RemoteConfigController.getInstance(this.mContext);
this.mRemoteConfig.init(var3); // a callback to call parseConfig when an update is available
this.parseConfig(this.mRemoteConfig.getRemoteConfig());
```

what is going on in `RemoteConfigController`? Not a ton...

```java
public class RemoteConfigController {
    private static RemoteConfigController mInstance;
    private Context mContext;
    private ConfigObserver.ConfigUpdater mUpdater = null;

    private RemoteConfigController(Context var1) {
        this.mContext = var1;
    }

    public static RemoteConfigController getInstance(Context var0) {
        if (mInstance == null) {
            mInstance = new RemoteConfigController(var0);
        }

        return mInstance;
    }

    public JSONArray getRemoteConfig() {
        return (new ConfigGrabber(this.mContext, "glyph_auth_app")).grabConfig();
    }

    public void init(ConfigCallback var1) {
        this.mUpdater = new 1(this, var1);
        (new ConfigObserver(this.mContext, new Handler(), this.mUpdater, "glyph_auth_app")).register();
    }
}
```

So we need to look in `com.nothing.onlineconfig` for this `ConfigObserver` and `ConfigGrabber`. It turns up in a lot of places, mostly in `system_ext`:

```
$ sudo grep -Flrn "ConfigObserver" /mnt/system
./system_ext/priv-app/SystemUI/SystemUI.apk
./system_ext/priv-app/LogKit/LogKit.apk
./system_ext/priv-app/SystemUITool/SystemUITool.apk
./system_ext/priv-app/NothingLauncher3/NothingLauncher3.apk
./system_ext/framework/qti-telephony-common.jar
./system_ext/app/NothingProxy/NothingProxy.apk
./system_ext/app/NtThirdParty/NtThirdParty.apk
./product/priv-app/GmsCore/GmsCore.apk
./system/system/framework/services.jar
./system/system/framework/framework.jar
./system/system/app/NfcNci/NfcNci.apk
```

- `NothingProxy` looks promising, let's travel there? Nope, just `com.nothing.proxy` stuff.
- What about `SystemUI`? It's huge, but nope.
- `SystemUITool`? And there we are, tucked away as `com.nothing.sdk.onlineconfig`:

![](nothing-phone/ConfigGrabber.png)

Wait, let's take a closer look.

```java
package com.nothing.sdk.onlineconfig;

import android.content.Context;
import com.nothing.sdk.utils.ClassReflection;
import com.nothing.sdk.utils.MethodReflection;
import java.lang.reflect.Constructor;
import org.json.JSONArray;

public class ConfigGrabber {
   private static final String CONFIG_GRABBER = "com.nothing.onlineconfig.ConfigGrabber";
   private Object mConfigGrabberInst;

   public ConfigGrabber(Context var1, String var2) {
      try {
         Constructor var3 = ClassReflection.findConstructor("com.nothing.onlineconfig.ConfigGrabber", new Class[]{Context.class, String.class});
         var3.setAccessible(true);
         this.mConfigGrabberInst = var3.newInstance(var1, var2);
      } catch (ReflectiveOperationException var4) {
         throw new RuntimeException(var4.getMessage());
      }
   }

   public JSONArray grabConfig() {
      return (JSONArray)MethodReflection.invokeMethod(MethodReflection.findMethod(ClassReflection.findClass("com.nothing.onlineconfig.ConfigGrabber"), "grabConfig"), this.mConfigGrabberInst);
   }
}
```

This isn't source code -- they've made a stub that finds the real ConfigGrabber class and delegates the `grabConfig` method to it, and they've done the same to ConfigObserver.
